Dada una lista de palabras se pide retornar la lista pero intercalando las
palabras desde el final y desde el inicio. 
 
Ejemplo: Hoy puede que llueva, se retorna llueva Hoy que puede.


oracion -> oracion " " palabra 		oracion.x = oracion.x || " " || palabra.x 
oracion -> palabra             		oracion.x = palabra.x 
oracion -> EOL                 		oracion.x = EOL

palabra -> palabra letra      		palabra.x = palabra.x || letra.x
palabra -> letra              		palabra.x = letra.x

letra ->  a                   		letra.x = "a"                                       
letra ->  b                   		letra.x = "b"                          
letra -> ...                      		....                      
letra ->  z                   		letra.x = "z"

-----------------------------------------------------------------------------

Tiene recursion por la izquerda? Si

oracion -> palabra R1 
oracion -> EOL
R1 -> " " palabra R1 
R1 -> E

palabra -> letra R2                 palabra.x = letra.x || R2.x
R2 -> letra R2                      R2.x = letra.x || R2.x
R2 -> E                             R2.x = " "

letra -> a | b | ... | z            letra.x = "a"

-----------------------------------------------------------------------------

Tiene factor comnun? No

-----------------------------------------------------------------------------

Conjunto Primero

oracion -> palabra R1 | EOL         P(oracion) = P(palabra R1) U P(EOL) = { a, b, c, ..., z } U {EOL} = { a, b, c, ..., z, EOL} 
R1 -> " " palabra R1 | E            P(R1) = P(" " palabra R1) U P(E) = { " " } U { E } = { " ", E }
palabra -> letra R2                 P(palabra) = P(letra R2) = { a, b, c, ..., z }
R2 -> letra R2 | E                  P(R2) = P(letra R2) U P(E) = { a, b, c,..., z } U { E } = { a, b, c, ..., z, E }

letra -> a | b | ... | z            P(letra) = P(a) U ... U P(z) = { a, b, c,... ,z }



--------------------------------------------------------------------------------
t -> p_r F1             t.x = 
F1 -> t p_r | p_r         F1.x = 
p_r -> p F2             p_r.x = 
F2 -> ' ' | e             F2.x = 
p -> l F3                 p.x = 
F3 -> p | e             F3.x = 
l -> [a~z]                 l.x =



BNF	 						Regla semántica
S -> palabra espacio S		S.x = palabra.x + espacio.x + S.x
S -> palabra				S.x = palabra.x
palabra -> letra r2			palabra.x = letra.x + r2.x
r2 -> letra r2 | e			r2.x = letra.x + r2.x
espacio -> ' ' espacio | e	espacio.x = ' ' + espacio.x || e
letra -> [a-z]				letra.x = [a-z]

BNF	 						Regla semántica 						Esquema de traducción
S -> palabra R1				S.x = palabra.x + R1.x 					palabra R1 {ordenar()}
R1 -> espacio S | e			R1.x = espacio.x + S.x || e				espacio S | e
palabra -> letra r2			palabra.x = letra.x + r2.x
r2 -> letra r2 | e			r2.x = letra.x + r2.x
espacio -> ' ' espacio | e	espacio.x = ' ' + espacio.x || e
letra -> [a-z]				letra.x = [a-z]

BNF	 						Regla semántica							Esquema de traducción
S -> palabra R1														{palabras.add(palabra) R1() ordenar()}
R1 -> espacio S
R1 -> e						R1.x = ''
palabra -> letra r2			palabra.x = letra.x || r2.x
r2 -> letra r2				r2.x = letra.x || r2.x
r2 -> e						r2.x = ''
espacio -> ' ' espacio		espacio.x = ' ' || espacio.x
espacio -> e				espacio.x = ''
letra -> [a-z]				letra.x = [a-z]

Conjuntos primeros
S -> palabra R1				P(S) = P(palabra R1) = {a, b, c, ..., z}
R1 -> espacio S | e			P(R1) = P(espacio S) U P(e) = { ' ' } U { e } = { ' ', e }
palabra -> letra r2			P(palabra) = P(letra r2) = {a, b, c, ..., z}
r2 -> letra r2 | e			P(r2) = P(letra r2) U P(e) = {a, b, c, ..., z} U { e } = {a, b, c, ..., z, e}
espacio -> ' ' espacio | e	P(espacio) = P(' ' espacio) U P(e) = { ' ' } U { e } = { ' ', e }
letra -> [a-z]				P(letra) = P([a-z]) = {a, b, c, ..., z}


6 texto

6 1 


texto(){
	espacio();
	texto2();
}

texto2(){
	palabra();
	espacio();
	texto();
}